# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Appl_idrologica
                                 A QGIS plugin
 Appl_idrologica
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-11-11
        copyright            : (C) 2021 by annagrass
        email                : anangrass@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'annagrass'
__date__ = '2021-11-11'
__copyright__ = '(C) 2021 by annagrass'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.core import QgsProcessing
from qgis.core import QgsProcessingAlgorithm
from qgis.core import QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterRasterLayer
from qgis.core import QgsProcessingParameterVectorLayer
from qgis.core import QgsProcessingParameterPoint
from qgis.core import QgsProcessingParameterRasterDestination
import processing


class Appl_idrologica(QgsProcessingAlgorithm):

    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterRasterLayer('DEM', 'DEM', defaultValue=None))
        self.addParameter(QgsProcessingParameterVectorLayer('Region', 'Regione Computazionale', types=[QgsProcessing.TypeVectorPolygon], defaultValue=None))
        self.addParameter(QgsProcessingParameterPoint('coordsezchiusura', 'Coordinate della Sezione di Chiusura', defaultValue='0.000000,0.000000'))
        self.addParameter(QgsProcessingParameterRasterDestination('ReticoloIdrografico2', 'Reticolo Idrografico 2', createByDefault=True, defaultValue=None))
        self.addParameter(QgsProcessingParameterRasterDestination('Dem_ritagliato', 'DEM_ritagliato', createByDefault=True, defaultValue=None))
        self.addParameter(QgsProcessingParameterRasterDestination('IndiceTopografico', 'Indice Topografico', createByDefault=True, defaultValue=None))

    def processAlgorithm(self, parameters, context, model_feedback):
        # Use a multi-step feedback, so that individual child algorithm progress reports are adjusted for the
        # overall progress through the model
        feedback = QgsProcessingMultiStepFeedback(8, model_feedback)
        results = {}
        outputs = {}

        # r.mask.vect
        alg_params = {
            '-i': False,
            'GRASS_MIN_AREA_PARAMETER': 0.0001,
            'GRASS_RASTER_FORMAT_META': '',
            'GRASS_RASTER_FORMAT_OPT': '',
            'GRASS_REGION_CELLSIZE_PARAMETER': 0,
            'GRASS_REGION_PARAMETER': None,
            'GRASS_SNAP_TOLERANCE_PARAMETER': -1,
            'cats': '',
            'input': parameters['DEM'],
            'vector': parameters['Region'],
            'where': '',
            'output': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Rmaskvect'] = processing.run('grass7:r.mask.vect', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(1)
        if feedback.isCanceled():
            return {}

        # r.watershed
        # Illustrare la questione threshold, che influenza l'estrazione del reticolo idrografico laddove si hanno scarse informazioni a contorno
        alg_params = {
            '-4': False,
            '-a': False,
            '-b': False,
            '-m': False,
            '-s': False,
            'GRASS_RASTER_FORMAT_META': '',
            'GRASS_RASTER_FORMAT_OPT': '',
            'GRASS_REGION_CELLSIZE_PARAMETER': 0,
            'GRASS_REGION_PARAMETER': None,
            'blocking': None,
            'convergence': None,
            'depression': None,
            'disturbed_land': None,
            'elevation': outputs['Rmaskvect']['output'],
            'flow': None,
            'max_slope_length': None,
            'memory': 300,
            'threshold': 2000,
            'accumulation': QgsProcessing.TEMPORARY_OUTPUT,
            'drainage': QgsProcessing.TEMPORARY_OUTPUT,
            'stream': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Rwatershed'] = processing.run('grass7:r.watershed', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(2)
        if feedback.isCanceled():
            return {}

        # r.slope.aspect
        alg_params = {
            '-a': True,
            '-e': False,
            '-n': False,
            'GRASS_RASTER_FORMAT_META': '',
            'GRASS_RASTER_FORMAT_OPT': '',
            'GRASS_REGION_CELLSIZE_PARAMETER': 0,
            'GRASS_REGION_PARAMETER': None,
            'elevation': outputs['Rmaskvect']['output'],
            'format': 0,
            'min_slope': 0,
            'precision': 0,
            'zscale': 1,
            'slope': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Rslopeaspect'] = processing.run('grass7:r.slope.aspect', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(3)
        if feedback.isCanceled():
            return {}

        # r.water.outlet
        alg_params = {
            'GRASS_RASTER_FORMAT_META': '',
            'GRASS_RASTER_FORMAT_OPT': '',
            'GRASS_REGION_CELLSIZE_PARAMETER': 0,
            'GRASS_REGION_PARAMETER': None,
            'coordinates': parameters['coordsezchiusura'],
            'input': outputs['Rwatershed']['drainage'],
            'output': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Rwateroutlet'] = processing.run('grass7:r.water.outlet', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(4)
        if feedback.isCanceled():
            return {}

        # r.mapcalc.simple
        # far notare che qualora si trasformasse questo reticolo in vettoriale così com'è si avrebbero problemi di ordine topologico (presenza di dangles e elementi circolari) soprattutto nelle aree a scarsa pendenza
        alg_params = {
            'GRASS_RASTER_FORMAT_META': '',
            'GRASS_RASTER_FORMAT_OPT': '',
            'GRASS_REGION_CELLSIZE_PARAMETER': 0,
            'GRASS_REGION_PARAMETER': None,
            'a': outputs['Rmaskvect']['output'],
            'b': outputs['Rwatershed']['stream'],
            'c': outputs['Rwateroutlet']['output'],
            'd': None,
            'e': None,
            'expression': 'if(C && B, A, null())',
            'f': None,
            'output': parameters['ReticoloIdrografico2']
        }
        outputs['Rmapcalcsimple'] = processing.run('grass7:r.mapcalc.simple', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        results['ReticoloIdrografico2'] = outputs['Rmapcalcsimple']['output']

        feedback.setCurrentStep(5)
        if feedback.isCanceled():
            return {}

        # r.mapcalc.simple
        alg_params = {
            'GRASS_RASTER_FORMAT_META': '',
            'GRASS_RASTER_FORMAT_OPT': '',
            'GRASS_REGION_CELLSIZE_PARAMETER': 0,
            'GRASS_REGION_PARAMETER': None,
            'a': outputs['Rwatershed']['accumulation'],
            'b': outputs['Rslopeaspect']['slope'],
            'c': None,
            'd': None,
            'e': None,
            'expression': 'log((A*400)/(tan(B*0.0174533)))',
            'f': None,
            'output': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Rmapcalcsimple'] = processing.run('grass7:r.mapcalc.simple', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(6)
        if feedback.isCanceled():
            return {}

        # r.mask.rast
        alg_params = {
            '-i': False,
            'GRASS_RASTER_FORMAT_META': '',
            'GRASS_RASTER_FORMAT_OPT': '',
            'GRASS_REGION_CELLSIZE_PARAMETER': 0,
            'GRASS_REGION_PARAMETER': None,
            'input': parameters['DEM'],
            'maskcats': '*',
            'raster': outputs['Rwateroutlet']['output'],
            'output': parameters['Dem_ritagliato']
        }
        outputs['Rmaskrast'] = processing.run('grass7:r.mask.rast', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        results['Dem_ritagliato'] = outputs['Rmaskrast']['output']

        feedback.setCurrentStep(7)
        if feedback.isCanceled():
            return {}

        # r.mask.rast
        # far notare che r.mapcalc dove non ha dato ritaglia il dato in output (la flow accumulation era calcolata su tutto il dem, mentre la pendenza solo sul dem ritagliato del chiascio)

#inoltre in questo casos pecifico dove la pendenza è pressoché nulla (ln di infinito) o dove l'accumulation è zero (ln di 0) ci sono (giustamente) buchi
        alg_params = {
            '-i': False,
            'GRASS_RASTER_FORMAT_META': '',
            'GRASS_RASTER_FORMAT_OPT': '',
            'GRASS_REGION_CELLSIZE_PARAMETER': 0,
            'GRASS_REGION_PARAMETER': None,
            'input': outputs['Rmapcalcsimple']['output'],
            'maskcats': '*',
            'raster': outputs['Rwateroutlet']['output'],
            'output': parameters['IndiceTopografico']
        }
        outputs['Rmaskrast'] = processing.run('grass7:r.mask.rast', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        results['IndiceTopografico'] = outputs['Rmaskrast']['output']
        return results

    def name(self):
        return 'appl_idrologica'

    def displayName(self):
        return 'appl_idrologica'

    def group(self):
        return ''

    def groupId(self):
        return ''

    def createInstance(self):
        return Appl_idrologica()
